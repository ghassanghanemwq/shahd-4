<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Shahd 4 Map</title>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
  }
}
</script>

<style>
  :root{
    --text:#0b0b10; --muted:#6c6c78; --edge:#e7e7ec;
    --primary:#8B0E2A; --primary-2:#A01832;
    --available:#f3f3f0;   /* off-white */
    --reserved:#9ad8ff;    /* baby blue */
    --sold:#df1a25;        /* red */
    --selected:#22c55e;    /* green */
  }

  html,body{height:100%;margin:0;background:#ffffff;color:var(--text);
    font:14px/1.45 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial}
  #scene{position:fixed;inset:0;background:#ffffff}
  canvas{display:block;width:100%;height:100%}
  #loading{position:absolute;inset:0;display:grid;place-items:center;color:#777;letter-spacing:.2em;text-transform:uppercase}

  /* Brand */
  #brand{position:fixed;left:16px;top:16px;z-index:9;display:flex;align-items:center;gap:10px;pointer-events:auto}
  #brand img{height:36px;display:block}
  @media (max-width:900px){ #brand img{height:28px} }

  /* Hover tooltip */
  #label{position:fixed;pointer-events:none;transform:translate(-50%,-120%);padding:6px 10px;background:rgba(0,0,0,.75);
    border:1px solid rgba(0,0,0,.1);border-radius:8px;color:#fff;font-weight:700;font-size:12px;
    box-shadow:0 8px 30px rgba(0,0,0,.15);display:none;z-index:6}

  /* Always-on canvas labels */
  .lotLabel{position:absolute;padding:2px 6px;border:1px solid rgba(0,0,0,.12);border-radius:6px;background:rgba(255,255,255,.85);
    color:#111;font-weight:700;font-size:11px;letter-spacing:.02em;text-shadow:none;pointer-events:none;user-select:none;white-space:nowrap;
    backdrop-filter:blur(2px);transition:opacity .15s linear}

  /* Legend */
  #legend{position:fixed;left:12px;bottom:12px;display:flex;gap:8px;z-index:5}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:#fff;border:1px solid var(--edge);color:#222}
  .chip::before{content:'';width:8px;height:8px;border-radius:50%}
  .chip.avail::before{background:var(--available)}
  .chip.resv::before{background:var(--reserved)}
  .chip.sold::before{background:var(--sold)}

  /* Search */
  #searchWrap{position:fixed;top:16px;right:700px;z-index:7;width:min(420px,50vw)}
  #search{width:100%;padding:12px 14px;border-radius:12px;border:1px solid #e6e6ee;background:#fff;color:#111;outline:none;
    box-shadow:0 0 0 0 rgba(139,14,42,0),0 12px 24px rgba(0,0,0,.05);transition:box-shadow .2s ease,border-color .2s ease}
  #search::placeholder{color:#9aa}
  #search:focus{border-color:#d7d7e2;box-shadow:0 0 0 3px rgba(160,24,50,.08),0 12px 30px rgba(0,0,0,.06)}
  #results{position:absolute;top:50px;left:0;right:0;background:#fff;border:1px solid #e8e8f0;border-radius:12px;overflow:auto;max-height:42vh;box-shadow:0 22px 40px rgba(0,0,0,.08);display:none}
  .result{display:flex;align-items:center;gap:10px;padding:12px 14px;cursor:pointer;color:#111}
  .result:hover{background:#fafafa;box-shadow:inset 0 0 0 1px #eee}
  .badge{font-size:11px;padding:3px 8px;border-radius:999px;border:1px solid #eee;color:#333;background:#f8f8ff;margin-left:auto}

  /* Drawer */
  #drawer{position:fixed;top:0;right:0;bottom:0;width:380px;background:#fff;border-left:1px solid #ececf3;
    box-shadow:-10px 0 28px rgba(0,0,0,.05);transform:translateX(100%);transition:transform .38s cubic-bezier(.2,.8,.2,1);z-index:8;overflow:auto}
  #drawer.open{transform:translateX(0)}
  #drawer header{display:flex;align-items:center;gap:10px;padding:14px 16px;border-bottom:1px solid #f0f0f6;position:sticky;top:0;background:#fff}
  #drawer header .title{font-weight:800;letter-spacing:.02em;color:#111}
  #content{padding:16px}
  .row{display:grid;grid-template-columns:110px 1fr;gap:10px;margin:10px 0}
  .muted{color:#666}
  .ghost{width:100%;padding:12px 14px;border:1px solid #e9e9f2;border-radius:12px;background:#fff;color:#111;font-weight:700;cursor:pointer}
  .primary{width:100%;padding:12px 14px;border:0;border-radius:12px;background:linear-gradient(180deg,var(--primary),var(--primary-2));color:#fff;font-weight:900;cursor:pointer;box-shadow:0 12px 30px rgba(139,14,42,.15);text-transform:uppercase;letter-spacing:.03em}

  /* Drawer toggle (hamburger) */
  #drawerToggle{
    position:fixed; right:8px; top:50%; transform:translateY(-50%);
    z-index:9; width:44px; height:44px; border-radius:999px; border:1px solid #ececf3; background:#fff;
    display:flex; align-items:center; justify-content:center; box-shadow:0 6px 16px rgba(0,0,0,.08); cursor:pointer;
  }
  #drawerToggle svg{display:block}
  @media (max-width:900px){
    #drawer{width:92vw}
    #searchWrap{right:16px; width:calc(100vw - 440px)}
    #drawerToggle{right:6px}
  }
</style>
</head>
<body>
  <a id="brand" href="#" aria-label="Brand"><img src="svg-01.svg" alt="Brand logo" /></a>

  <div id="scene">
    <div id="loading">LOADING… 0%</div>
    <canvas id="c"></canvas>
    <div id="label"></div>
    <div id="legend">
      <span class="chip avail">Available</span>
      <span class="chip resv">Reserved</span>
      <span class="chip sold">Sold</span>
    </div>
  </div>

  <!-- Hamburger toggle for the side panel -->
  <button id="drawerToggle" title="Toggle panel" aria-label="Toggle panel">
    <svg width="22" height="22" viewBox="0 0 24 24" fill="none" aria-hidden="true">
      <path d="M4 7h16M4 12h16M4 17h16" stroke="#8B0E2A" stroke-width="2" stroke-linecap="round"/>
    </svg>
  </button>

  <!-- Drawer (thumbnail removed as requested) -->
  <aside id="drawer" aria-label="Parcel details">
    <header>
      <svg width="22" height="22" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M3 11h18M5 19h14M7 5h10" stroke="#8B0E2A" stroke-width="1.6" stroke-linecap="round"/></svg>
      <div class="title">Parcel Details</div>
    </header>
    <div id="content">
      <p class="muted">Click a lot or use search.</p>
      <!-- Removed: <img id="thumb" class="thumb" alt="Lot preview" /> -->
      <div class="row"><div class="muted">Lot</div><div id="lotId">—</div></div>
      <div class="row"><div class="muted">Area</div><div id="area">—</div></div>
      <div class="row"><div class="muted">Price</div><div id="price">—</div></div>
      <div class="row"><div class="muted">Status</div><div id="status"><span class="chip">—</span></div></div>
      <div class="row"><div class="muted">Description</div><div id="notes">—</div></div>
      <div class="row" style="grid-template-columns:1fr 1fr">
        <button id="brochureBtn" class="ghost">Open Brochure</button>
        <button id="inquireBtn" class="primary">Inquire</button>
      </div>
    </div>
  </aside>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';
import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

/* ========= CONFIG ========= */
const CONFIG = { glbUrl:'./map.glb', highlight:0x8B0E2A };

/* ========= DATA ========= */
let RAW = {}, LOTS = {}, INDEX = [];
fetch('lots_final_with_excel_desc.json')
  .then(r=>r.json())
  .then(d=>{ RAW=d||{}; normalize(); })
  .catch(()=>{});

/* ========= DOM ========= */
const canvas = document.getElementById('c');
const loading = document.getElementById('loading');
const label   = document.getElementById('label');
const drawer  = document.getElementById('drawer');
const lotIdEl = document.getElementById('lotId');
const areaEl  = document.getElementById('area');
const priceEl = document.getElementById('price');
const statusEl= document.getElementById('status');
const notesEl = document.getElementById('notes');
const search  = document.getElementById('search');
const results = document.getElementById('results');
const drawerToggle = document.getElementById('drawerToggle');

/* Drawer toggle logic */
drawerToggle.addEventListener('click', ()=>{
  drawer.classList.toggle('open');
});

/* ========= THREE ========= */
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio, 1.8));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;

const scene = new THREE.Scene();
const pmrem = new THREE.PMREMGenerator(renderer);
scene.environment = pmrem.fromScene(new RoomEnvironment(renderer), 0.03).texture;

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 4000);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.maxPolarAngle = Math.PI * 0.49;
controls.minPolarAngle = 0.28;
controls.enablePan = false;

/* Lights & WHITE ground */
const key = new THREE.DirectionalLight(0xffffff,1.05); key.position.set(2,4,1); scene.add(key);
scene.add(new THREE.AmbientLight(0xffffff,0.45));

const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(2000,2000),
  new THREE.MeshStandardMaterial({color:0xffffff, roughness:.92, metalness:0})
);
ground.rotation.x = -Math.PI/2; ground.position.y=-0.02; scene.add(ground);

/* Subtle bloom */
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.48, 0.85, 0.2);
bloom.threshold = 0.85; bloom.strength = 0.08; bloom.radius = 0.15;
composer.addPass(bloom);

/* CSS2D overlay for labels */
const labelRenderer = new CSS2DRenderer();
labelRenderer.setSize(innerWidth, innerHeight);
labelRenderer.domElement.style.position = 'fixed';
labelRenderer.domElement.style.inset = '0';
labelRenderer.domElement.style.pointerEvents = 'none';
document.body.appendChild(labelRenderer.domElement);

const ray = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let GLB, hoveredLotId=null, selectedLotId=null;

/* Per-lot containers */
const LOT_LABELS = new Map();    // id -> { node: CSS2DObject, center: Vector3 }
const LOT_MESHES = new Map();    // id -> Mesh[] (all submeshes)

/* ========= HELPERS ========= */
const pad3 = n => String(n).padStart(3,'0');
const normId = n => `Lot_${pad3(n)}`;

function extractLotNumber(name){
  if(!name) return null;
  const base = String(name).split(/[\\/|]/).pop().replace(/\.\d+$/,'');
  const m = base.match(/lot[\s_\-]*0*(\d{1,4})/i);
  return m ? m[1] : null;
}
function getLotIdFromObjectName(name){
  const n = extractLotNumber(name);
  return n ? normId(n) : null;
}

function fit(root){
  const box = new THREE.Box3().setFromObject(root);
  const c = box.getCenter(new THREE.Vector3());
  const s = box.getSize(new THREE.Vector3());
  const r = Math.max(s.x,s.y,s.z)*0.6;
  const dir = new THREE.Vector3(1,0.8,1).normalize();
  camera.position.copy(c.clone().add(dir.multiplyScalar(r*2.3)));
  controls.target.copy(c); controls.minDistance=r*0.2; controls.maxDistance=r*10;
  camera.near=Math.max(0.1,r/100); camera.far=r*100; camera.updateProjectionMatrix(); controls.update();
}

function pick(x,y){
  mouse.set((x/canvas.clientWidth)*2-1, -(y/canvas.clientHeight)*2+1);
  ray.setFromCamera(mouse, camera);
  const hits = ray.intersectObjects(GLB?GLB.children:[], true);
  for(const h of hits){
    const id = getLotIdFromObjectName(h.object?.name||'');
    if(id) return id;
  }
  return null;
}

function normalize(){
  LOTS = {};
  INDEX = [];
  const seen = new Set();

  // Expecting keys like "Lot_001" with fields Area, Price, Status, Description
  for(const [k,v] of Object.entries(RAW)){
    if(/^Lot_\d{3,4}$/.test(k)){
      LOTS[k] = {
        area: v.Area ?? null,
        unit: 'm²',
        price: v.Price ?? null,
        status: v.Status ? String(v.Status).toLowerCase() : null,
        notes: v.Description ?? null
      };
      if(!seen.has(k)){ INDEX.push({id:k}); seen.add(k); }
    }
  }

  // If GLB already loaded, add any lots present there too (for search)
  if(GLB){
    GLB.traverse(o=>{
      if(!o.isMesh || !o.name) return;
      const id = getLotIdFromObjectName(o.name); if(!id) return;
      if(!seen.has(id)){ INDEX.push({id}); seen.add(id); }
    });
  }

  INDEX.sort((a,b)=>a.id.localeCompare(b.id,undefined,{numeric:true}));
}

function openDrawer(){ drawer.classList.add('open'); }

/* Mesh color helpers for entire-lot selection */
function setMeshesColor(meshes, cssColor){
  meshes.forEach(m=>{
    m.userData = m.userData || {};
    if (m.userData._origColor === undefined && m.material?.color) {
      m.userData._origColor = m.material.color.getHex();
    }
    if (m.material?.color) m.material.color.set(cssColor);
  });
}
function restoreMeshesColor(meshes){
  meshes.forEach(m=>{
    if (m.userData && m.userData._origColor !== undefined && m.material?.color) {
      m.material.color.setHex(m.userData._origColor);
    }
    if (m.material?.emissive){
      m.material.emissive.set(0);
      m.material.emissiveIntensity = 0;
    }
  });
}

function setLotHover(lotId){
  if(hoveredLotId === lotId) return;
  if(hoveredLotId && hoveredLotId !== selectedLotId){
    const prev = LOT_MESHES.get(hoveredLotId) || [];
    prev.forEach(m=>{ m.material?.emissive?.set(0); m.material.emissiveIntensity=0; });
  }
  hoveredLotId = lotId;
  if(hoveredLotId && hoveredLotId !== selectedLotId){
    const ms = LOT_MESHES.get(hoveredLotId) || [];
    ms.forEach(m=>{
      m.material?.emissive?.setHex(CONFIG.highlight);
      m.material.emissiveIntensity = .10;
    });
  }
}

/* ✅ Selection: entire lot becomes green */
function setLotSelected(lotId){
  if(selectedLotId && selectedLotId !== lotId){
    restoreMeshesColor(LOT_MESHES.get(selectedLotId) || []);
  }
  selectedLotId = lotId;
  const meshes = LOT_MESHES.get(lotId) || [];
  const selCSS = getComputedStyle(document.documentElement).getPropertyValue('--selected').trim() || '#22c55e';
  setMeshesColor(meshes, selCSS);
  meshes.forEach(m=>{
    m.material?.emissive?.setHex(CONFIG.highlight);
    m.material.emissiveIntensity = .22;
  });
  if (lotId) showDetails(lotId);
}

function showDetails(idOrName){
  const n = extractLotNumber(idOrName) || extractLotNumber(String(idOrName));
  const display = n ? normId(n) : idOrName;
  const d = LOTS[display] || null;

  openDrawer();
  lotIdEl.textContent = display.replace(/^lot_/i,'');
  areaEl.textContent  = d?.area ? `${Number(d.area).toLocaleString()} ${d.unit||'m²'}` : '—';
  /* JOD, no decimals */
  priceEl.textContent = (typeof d?.price === 'number')
    ? `JOD ${Number(d.price).toLocaleString('en-JO')}`
    : '—';

  const s = d?.status || '';
  const chip=document.createElement('span');
  chip.className='chip '+(s.startsWith('ava')?'avail':s.startsWith('res')?'resv':s.startsWith('sold')?'sold':'');
  chip.textContent = s ? s[0].toUpperCase()+s.slice(1) : '—';
  statusEl.innerHTML=''; statusEl.appendChild(chip);

  notesEl.textContent = d?.notes || '—';
}

function buildLotMeshesAndLabels(){
  LOT_LABELS.forEach(({node})=> node.parent?.remove(node));
  LOT_LABELS.clear();
  LOT_MESHES.clear();

  const unions = new Map(); // id -> Box3

  GLB.traverse(o=>{
    if(!o.isMesh || !o.name) return;
    const n = extractLotNumber(o.name); if(!n) return;
    const id = normId(n);
    o.name = id; // normalize

    const arr = LOT_MESHES.get(id) || [];
    arr.push(o);
    LOT_MESHES.set(id, arr);

    if(!o.material || !('color' in o.material)){
      o.material = new THREE.MeshStandardMaterial({color:0xf3f3f0, metalness:.06, roughness:.8});
    }

    const box = new THREE.Box3().setFromObject(o);
    const u = unions.get(id) || new THREE.Box3();
    u.union(box);
    unions.set(id, u);
  });

  unions.forEach((box, id)=>{
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    const el = document.createElement('div');
    el.className = 'lotLabel';
    el.textContent = id.replace('Lot_','');
    const css = new CSS2DObject(el);
    css.position.set(center.x, center.y + Math.max(size.y*0.05, 1.0), center.z);
    scene.add(css);
    LOT_LABELS.set(id, { node: css, center });
  });
}

function recolorByStatus(){
  const offWhite = getComputedStyle(document.documentElement).getPropertyValue('--available').trim() || '#f3f3f0';
  LOT_MESHES.forEach((meshes, id)=>{
    const d = LOTS[id] || {};
    const s = (d.status||'').toLowerCase();
    let base = offWhite;
    if(s.startsWith('sold')) base = '#df1a25';
    else if(s.startsWith('res')) base = '#9ad8ff';

    meshes.forEach(o=>{
      const mat = (o.material && o.material.clone()) || new THREE.MeshStandardMaterial();
      mat.color.set(base);
      mat.metalness = 0.06; mat.roughness = 0.6;
      o.material = mat;
    });
  });
}

function updateLabelOpacity(){
  const d = camera.position.distanceTo(controls.target);
  const t0 = 15, t1 = 40;
  const k = THREE.MathUtils.clamp((d - t0) / (t1 - t0), 0, 1);
  const opacity = 0.2 + 0.8 * k;
  LOT_LABELS.forEach(({node})=>{
    if(node.element) node.element.style.opacity = String(opacity);
  });
}

/* ========= LOAD GLB ========= */
const resolvedGLB = new URL(CONFIG.glbUrl, location.href).href;
const manager = new THREE.LoadingManager();
manager.onStart = ()=>{ loading.textContent = 'Loading… 0%'; };
manager.onError = (url)=>{ console.warn('Asset failed:', url); };

let progressTimer = setTimeout(()=>{
  loading.textContent = 'Still loading… If this stays, check that\n\n• "map.glb" is next to this HTML\n• Using http(s) not file://\n• No ad-block/firewall is blocking unpkg loaders';
}, 6000);

function createLoader(withExtras=true){
  const L = new GLTFLoader(manager);
  if(withExtras){
    const draco = new DRACOLoader(); draco.setDecoderPath('https://unpkg.com/three@0.161.0/examples/jsm/libs/draco/');
    L.setDRACOLoader(draco);
    L.setKTX2Loader(new KTX2Loader().setTranscoderPath('https://unpkg.com/three@0.161.0/examples/jsm/libs/basis/').detectSupport(renderer));
    L.setMeshoptDecoder(MeshoptDecoder);
  }
  return L;
}
function startRender(){ render(); requestAnimationFrame(()=>loading.remove()); clearTimeout(progressTimer); }
function loadGLB(url){
  const loaderA = createLoader(true);
  loaderA.load(url, (gltf)=>{ GLB=gltf.scene; afterGLBLoaded(); }, onProgress, (err)=>{
    console.warn('Primary load failed, retrying without KTX2/Draco…', err);
    const loaderB = createLoader(false);
    loaderB.load(url, (gltf)=>{ GLB=gltf.scene; afterGLBLoaded(); }, onProgress, (err2)=>{
      console.error('Failed to load GLB.', err2); loading.textContent = 'Failed to load GLB. Check console.';
    });
  });
}
function onProgress(ev){
  const pct = ev && ev.total ? Math.floor((ev.loaded/ev.total)*100) : 0;
  loading.textContent = 'Loading… ' + pct + '%';
}
function afterGLBLoaded(){
  scene.add(GLB);
  fit(GLB);
  buildLotMeshesAndLabels();
  normalize();         // refresh index with GLB names too
  recolorByStatus();
  startRender();
}
try { loadGLB(resolvedGLB); } catch(e){ console.error(e); loading.textContent='Failed to start loader. See console.'; }

/* ========= INTERACTION ========= */
canvas.addEventListener('mousemove', e=>{
  const lotId = pick(e.clientX, e.clientY);
  setLotHover(lotId);
  if(lotId){
    const n = extractLotNumber(lotId);
    label.textContent = n ? `Lot ${pad3(n)}` : lotId;
    label.style.left = e.clientX+'px'; label.style.top = e.clientY+'px'; label.style.display='block';
  } else label.style.display='none';
});
canvas.addEventListener('mouseleave', ()=>{ setLotHover(null); label.style.display='none'; });

canvas.addEventListener('click', e=>{
  const lotId = pick(e.clientX,e.clientY);
  if(lotId) focusLot(lotId);
});

window.addEventListener('resize', ()=>{
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight); composer.setSize(innerWidth,innerHeight);
  labelRenderer.setSize(innerWidth, innerHeight);
});

controls.addEventListener('change', ()=>{
  const d = camera.position.distanceTo(controls.target);
  renderer.toneMappingExposure = THREE.MathUtils.clamp(1.15 - d * 0.01, 0.9, 1.2);
  updateLabelOpacity();
});

/* ========= SEARCH ========= */
function searchLots(q){
  q=(q||'').trim().toLowerCase(); if(!q) return [];
  const num=q.replace(/[^0-9]/g,'');
  return INDEX.filter(it=>{
    const id=it.id.toLowerCase(), label=id.replace(/^lot_/,'');
    const notes=(RAW[it.id]?.Description||'').toLowerCase();
    return id.includes(q) || (num && label.includes(num)) || notes.includes(q);
  });
}
function showResults(items){
  results.innerHTML=''; if(!items.length){ results.style.display='none'; return; }
  for(const it of items.slice(0,12)){
    const row=document.createElement('div'); row.className='result';
    row.innerHTML=`<strong>${it.id.replace(/^lot_/i,'Lot ')}</strong>`;
    const v = RAW[it.id]||{};
    const b=document.createElement('span'); b.className='badge';
    b.textContent=(v.Status||'').toString().toUpperCase()||'—';
    row.appendChild(b);
    row.onclick=()=>{ focusLot(it.id); results.style.display='none'; };
    results.appendChild(row);
  }
  results.style.display='block';
}
const debounce=(fn,ms=120)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; };
const debouncedShow=debounce(()=> showResults(searchLots(search.value)), 120);
search.addEventListener('input', debouncedShow);

let selIndex=-1;
search.addEventListener('keydown', (e)=>{
  const items=[...results.querySelectorAll('.result')];
  if(e.key==='Escape'){
    e.preventDefault(); search.value=''; results.style.display='none'; selIndex=-1; search.blur(); return;
  }
  if(e.key==='ArrowDown'){
    e.preventDefault(); if(!items.length) return; selIndex=(selIndex+1)%items.length; items.forEach((el,i)=>el.style.background=i===selIndex?'#fafafa':'' );
  } else if(e.key==='ArrowUp'){
    e.preventDefault(); if(!items.length) return; selIndex=(selIndex-1+items.length)%items.length; items.forEach((el,i)=>el.style.background=i===selIndex?'#fafafa':'' );
  } else if(e.key==='Enter'){
    e.preventDefault(); if(items.length && selIndex>=0){ items[selIndex].click(); selIndex=-1; return; }
    const v=search.value.trim(); const m=v.match(/\d{1,4}/); const id = m?normId(m[0]):v.replace(/\s+/g,'_');
    focusLot(id); results.style.display='none';
  }
});
document.addEventListener('click', (e)=>{
  if(!results.contains(e.target) && e.target!==search) { results.style.display='none'; selIndex=-1; }
});

/* ========= CAMERA FOCUS ========= */
function focusLot(idOrName){
  const n = extractLotNumber(idOrName);
  const lotId = n ? normId(n) : (getLotIdFromObjectName(idOrName) || idOrName);
  const info = LOT_LABELS.get(lotId);
  if(info){
    const c = info.center;
    controls.target.copy(c);
    camera.position.copy(c.clone().add(new THREE.Vector3(1,0.85,1).normalize().multiplyScalar(18)));
    controls.update();
    setLotSelected(lotId);
    return;
  }
  const ms = LOT_MESHES.get(lotId);
  if(!ms || !ms.length){ alert('Lot not found: '+lotId); return; }
  const box=new THREE.Box3(); ms.forEach(m=>box.union(new THREE.Box3().setFromObject(m)));
  const c=box.getCenter(new THREE.Vector3()), s=box.getSize(new THREE.Vector3()).length();
  controls.target.copy(c);
  camera.position.copy(c.clone().add(new THREE.Vector3(1,0.85,1).normalize().multiplyScalar(Math.max(6, s*1.8))));
  controls.update();
  setLotSelected(lotId);
}

/* ========= RENDER ========= */
function render(){
  requestAnimationFrame(render);
  controls.update();
  composer.render();
  labelRenderer.render(scene, camera);
}
</script>
</body>
</html>
